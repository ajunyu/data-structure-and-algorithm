# 递归

栈的非常重要的一个应用就是用来实现递归。

## 设计递归算法的方法

递归算法就是在算法中直接或间接调用算法本身的算法。使用递归算法的前提有两个：

1. 原问题可以层层分解为类似的子问题，且子问题比原问题的规模更小
2. 规模最小的子问题具有直接解

设计递归算法的方法是：

1. 寻找分解方法：将原问题转化为子问题求解。（例如，n! = n * (n - 1)!）
2. 设计递归出口：即根据规模最小的子问题确定递归终止条件。（例如，求解 n! 时，当 n = 1 时，n! = 1）

## 递归过程的实现

当递归函数调用时，应按照“后调用先返回”的原则处理调用过程，因此函数之间的信息传递和控制转移必须通过栈来实现。系统将整个程序运行时所需的数据空间安排在一个栈中，每当调用一个函数时，就为它在栈顶分配一个存储区，而每当从一个函数退出时，就释放它的存储区。显然，当前正在运行的函数的数据区必在栈顶。

## 递归算法到非递归算法的转换

递归算法具有两个特性：

1. 递归算法是一种分而治之、把复杂问题分解为简单问题的求解问题的方法，对求解某些复杂问题，递归算法的分析方法是有效的。
2. 递归算法的效率较低。

为此，在求解某些问题时，我们希望通过递归算法分析问题，用非递归算法求解具体问题。

### 消除递归的原因

1. 有利于提高算法时空性能，因为递归执行时需要系统提供隐式栈实现递归，效率较低。
2. 无应用递归语句的语言设施环境条件，有些计算机语言不支持递归功能，如 FORTRAN、C 语言中无递归机制。
3. 递归算法是一次执行完，这在处理有些问题时不合适，也存在一个把递归算法转化为非递归算法的需求。

常用的有两类消除递归方法。

1. 一类是简单递归问题的转换，对于尾递归和单向递归的算法，可用循环结构的算法替代。
2. 另一类是基于栈的递归消除，即将递归中隐含的栈机制转化为由用户直接控制的明显的栈。利用堆栈保存参数，由于堆栈的后进先出特性吻合递归算法的执行过程，因而可用非递归算法替代递归算法。（第6章树中再做介绍）

### 简单递归的消除

1. 单向递归
    单向递归是指递归函数中虽然有一处以上的递归调用语句，但各次递归调用语句的参数只和主调用函数有关，相互之间参数无关，并且这类递归调用语句处于算法的最后。

    计算斐波那契数列的递归算法就是单向递归的一个典型例子。

    ``` c
    int Fib(int n)
    {
        // 递归出口
        if (n == 0 || n == 1) return n;
        // 递归调用
        else return Fib(n - 1) + Fib(n - 2);
    }
    ```

    非递归算法如下：

    ``` c
    int Fib(int n)
    {
        int x, y, z;
        if (n == 0 || n == 1) return n;
        else {
            x = 0;
            y = 1;
            for (int i = 2; i <= n; i++) {
                z = y;
                y = x + y;
                x = z;
            }

            return y;
        }
    }
    ```

2. 尾递归
    尾递归是指递归调用语句只有一个，而且是处于算法的最后，尾递归是单向递归的特例。
    求 n! 的递归算法

    ``` c
    long Fact(int n)
    {
        if (n == 0) return 1;
        return n * Fact(n - 1);
    }
    ```

    非递归算法如下：

    ``` c
    long Fact(int n)
    {
        int fac = 1;
        for(int i = 1; i <= n; i++)
            fac = fac * i;
        return fac;
    }
    ```
